## Цикл Зоображення
[Клієнт] → [Python FastAPI] → [C++ OpenCV] → [Результат] → [Клієнт]

### 1. Клієнт
Клієнт надсилає фото зображення на сервер.

### 2. Python FastAPI
Python FastAPI сервер отримує фото зображення та передає його на C++ OpenCV сервер.
Всередині  це працює так:
Читаємо бінарні дані та конвертуємо його в numpy array.
```python
image.read()
nparr = np.frombuffer(contents, np.uint8)
img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
```
Структура зообращення в numpy array:
---
Numpy array:
Порядок координат - (rows(ширина), cols(висота), channels(кількість каналів))

Порядок кольорів  - RGB

Індексація	      - [y, x, channel]

Channels:
Канали - це кількість кольорових компонентів у кожному пікселі.
1 канал - градації сірого (чорно-біле)
3 канали - кольорове зображення (RGB або BGR)
4 канали - кольорове з прозорістю (RGBA)


Приклад: 3 канали(RGB ,BGR)- (256, 256, 3)


Візуалізація даних в numpy array:
---
```
# Зображення 2x2 пікселі, 3 канали (BGR)
image = np.array([
    # Рядок 0
    [
        [255, 0, 0],     # Піксель (0,0): Blue
        [0, 255, 0]      # Піксель (0,1): Green
    ],
    # Рядок 1  
    [
        [0, 0, 255],     # Піксель (1,0): Red
        [255, 255, 255]  # Піксель (1,1): White
    ]
])

print(image.shape)  # (2, 2, 3) - height, width, channels
```


### 3. C++ OpenCV
C++ OpenCV сервер обробляє фото зображення та повертає результат.
Після того як С++ отримав зоображення в numpy array форматі,
ми конвертуємо його в cv::Mat формат ,  для роботи OpenCV  з зоображенням.

cv:Mat формат:
class Mat {
public:
    int rows;      
    int cols;           
    int type();        
    int channels();    
    uchar* data;       
    size_t step;        
};

Тобто ми можемо впросто взяти наявні дані з numpy array та створити cv::Mat формат.

### 4. Результат